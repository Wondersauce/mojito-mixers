{"version":3,"file":"FieldsOnCorrectTypeRule.mjs.js","sources":["../../../../../../node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs"],"sourcesContent":["import { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { naturalCompare } from '../../jsutils/naturalCompare.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport {\n  isAbstractType,\n  isInterfaceType,\n  isObjectType,\n} from '../../type/definition.mjs';\n\n/**\n * Fields on correct type\n *\n * A GraphQL document is only valid if all fields selected are defined by the\n * parent type, or are an allowed meta field such as __typename.\n *\n * See https://spec.graphql.org/draft/#sec-Field-Selections\n */\nexport function FieldsOnCorrectTypeRule(context) {\n  return {\n    Field(node) {\n      const type = context.getParentType();\n\n      if (type) {\n        const fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          // This field doesn't exist, lets look for suggestions.\n          const schema = context.getSchema();\n          const fieldName = node.name.value; // First determine if there are any suggested types to condition on.\n\n          let suggestion = didYouMean(\n            'to use an inline fragment on',\n            getSuggestedTypeNames(schema, type, fieldName),\n          ); // If there are no suggested types, then perhaps this was a typo?\n\n          if (suggestion === '') {\n            suggestion = didYouMean(getSuggestedFieldNames(type, fieldName));\n          } // Report an error, including helpful suggestions.\n\n          context.reportError(\n            new GraphQLError(\n              `Cannot query field \"${fieldName}\" on type \"${type.name}\".` +\n                suggestion,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n  };\n}\n/**\n * Go through all of the implementations of type, as well as the interfaces that\n * they implement. If any of those types include the provided field, suggest them,\n * sorted by how often the type is referenced.\n */\n\nfunction getSuggestedTypeNames(schema, type, fieldName) {\n  if (!isAbstractType(type)) {\n    // Must be an Object type, which does not have possible fields.\n    return [];\n  }\n\n  const suggestedTypes = new Set();\n  const usageCount = Object.create(null);\n\n  for (const possibleType of schema.getPossibleTypes(type)) {\n    if (!possibleType.getFields()[fieldName]) {\n      continue;\n    } // This object type defines this field.\n\n    suggestedTypes.add(possibleType);\n    usageCount[possibleType.name] = 1;\n\n    for (const possibleInterface of possibleType.getInterfaces()) {\n      var _usageCount$possibleI;\n\n      if (!possibleInterface.getFields()[fieldName]) {\n        continue;\n      } // This interface type defines this field.\n\n      suggestedTypes.add(possibleInterface);\n      usageCount[possibleInterface.name] =\n        ((_usageCount$possibleI = usageCount[possibleInterface.name]) !==\n          null && _usageCount$possibleI !== void 0\n          ? _usageCount$possibleI\n          : 0) + 1;\n    }\n  }\n\n  return [...suggestedTypes]\n    .sort((typeA, typeB) => {\n      // Suggest both interface and object types based on how common they are.\n      const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];\n\n      if (usageCountDiff !== 0) {\n        return usageCountDiff;\n      } // Suggest super types first followed by subtypes\n\n      if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {\n        return -1;\n      }\n\n      if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {\n        return 1;\n      }\n\n      return naturalCompare(typeA.name, typeB.name);\n    })\n    .map((x) => x.name);\n}\n/**\n * For the field name provided, determine if there are any similar field names\n * that may be the result of a typo.\n */\n\nfunction getSuggestedFieldNames(type, fieldName) {\n  if (isObjectType(type) || isInterfaceType(type)) {\n    const possibleFieldNames = Object.keys(type.getFields());\n    return suggestionList(fieldName, possibleFieldNames);\n  } // Otherwise, must be a Union type, which does not define fields.\n\n  return [];\n}\n"],"names":[],"mappings":"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"}