{"version":3,"file":"PossibleTypeExtensionsRule.mjs.js","sources":["../../../../../../node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs"],"sourcesContent":["import { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { inspect } from '../../jsutils/inspect.mjs';\nimport { invariant } from '../../jsutils/invariant.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { isTypeDefinitionNode } from '../../language/predicates.mjs';\nimport {\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isObjectType,\n  isScalarType,\n  isUnionType,\n} from '../../type/definition.mjs';\n\n/**\n * Possible type extension\n *\n * A type extension is only valid if the type is defined and has the same kind.\n */\nexport function PossibleTypeExtensionsRule(context) {\n  const schema = context.getSchema();\n  const definedTypes = Object.create(null);\n\n  for (const def of context.getDocument().definitions) {\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = def;\n    }\n  }\n\n  return {\n    ScalarTypeExtension: checkExtension,\n    ObjectTypeExtension: checkExtension,\n    InterfaceTypeExtension: checkExtension,\n    UnionTypeExtension: checkExtension,\n    EnumTypeExtension: checkExtension,\n    InputObjectTypeExtension: checkExtension,\n  };\n\n  function checkExtension(node) {\n    const typeName = node.name.value;\n    const defNode = definedTypes[typeName];\n    const existingType =\n      schema === null || schema === void 0 ? void 0 : schema.getType(typeName);\n    let expectedKind;\n\n    if (defNode) {\n      expectedKind = defKindToExtKind[defNode.kind];\n    } else if (existingType) {\n      expectedKind = typeToExtKind(existingType);\n    }\n\n    if (expectedKind) {\n      if (expectedKind !== node.kind) {\n        const kindStr = extensionKindToTypeName(node.kind);\n        context.reportError(\n          new GraphQLError(`Cannot extend non-${kindStr} type \"${typeName}\".`, {\n            nodes: defNode ? [defNode, node] : node,\n          }),\n        );\n      }\n    } else {\n      const allTypeNames = Object.keys({\n        ...definedTypes,\n        ...(schema === null || schema === void 0\n          ? void 0\n          : schema.getTypeMap()),\n      });\n      const suggestedTypes = suggestionList(typeName, allTypeNames);\n      context.reportError(\n        new GraphQLError(\n          `Cannot extend type \"${typeName}\" because it is not defined.` +\n            didYouMean(suggestedTypes),\n          {\n            nodes: node.name,\n          },\n        ),\n      );\n    }\n  }\n}\nconst defKindToExtKind = {\n  [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,\n  [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,\n  [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,\n  [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,\n  [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,\n  [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n};\n\nfunction typeToExtKind(type) {\n  if (isScalarType(type)) {\n    return Kind.SCALAR_TYPE_EXTENSION;\n  }\n\n  if (isObjectType(type)) {\n    return Kind.OBJECT_TYPE_EXTENSION;\n  }\n\n  if (isInterfaceType(type)) {\n    return Kind.INTERFACE_TYPE_EXTENSION;\n  }\n\n  if (isUnionType(type)) {\n    return Kind.UNION_TYPE_EXTENSION;\n  }\n\n  if (isEnumType(type)) {\n    return Kind.ENUM_TYPE_EXTENSION;\n  }\n\n  if (isInputObjectType(type)) {\n    return Kind.INPUT_OBJECT_TYPE_EXTENSION;\n  }\n  /* c8 ignore next 3 */\n  // Not reachable. All possible types have been considered\n\n  false || invariant(false, 'Unexpected type: ' + inspect(type));\n}\n\nfunction extensionKindToTypeName(kind) {\n  switch (kind) {\n    case Kind.SCALAR_TYPE_EXTENSION:\n      return 'scalar';\n\n    case Kind.OBJECT_TYPE_EXTENSION:\n      return 'object';\n\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      return 'interface';\n\n    case Kind.UNION_TYPE_EXTENSION:\n      return 'union';\n\n    case Kind.ENUM_TYPE_EXTENSION:\n      return 'enum';\n\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return 'input object';\n    // Not reachable. All possible types have been considered\n\n    /* c8 ignore next */\n\n    default:\n      false || invariant(false, 'Unexpected kind: ' + inspect(kind));\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;AAgBA;AACA;AACA;AACA;AACA;AACO,SAAS,0BAA0B,CAAC,OAAO,EAAE;AACpD,EAAE,MAAM,MAAM,GAAG,OAAO,CAAC,SAAS,EAAE,CAAC;AACrC,EAAE,MAAM,YAAY,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;AAC3C;AACA,EAAE,KAAK,MAAM,GAAG,IAAI,OAAO,CAAC,WAAW,EAAE,CAAC,WAAW,EAAE;AACvD,IAAI,IAAI,oBAAoB,CAAC,GAAG,CAAC,EAAE;AACnC,MAAM,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC;AACzC,KAAK;AACL,GAAG;AACH;AACA,EAAE,OAAO;AACT,IAAI,mBAAmB,EAAE,cAAc;AACvC,IAAI,mBAAmB,EAAE,cAAc;AACvC,IAAI,sBAAsB,EAAE,cAAc;AAC1C,IAAI,kBAAkB,EAAE,cAAc;AACtC,IAAI,iBAAiB,EAAE,cAAc;AACrC,IAAI,wBAAwB,EAAE,cAAc;AAC5C,GAAG,CAAC;AACJ;AACA,EAAE,SAAS,cAAc,CAAC,IAAI,EAAE;AAChC,IAAI,MAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC;AACrC,IAAI,MAAM,OAAO,GAAG,YAAY,CAAC,QAAQ,CAAC,CAAC;AAC3C,IAAI,MAAM,YAAY;AACtB,MAAM,MAAM,KAAK,IAAI,IAAI,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;AAC/E,IAAI,IAAI,YAAY,CAAC;AACrB;AACA,IAAI,IAAI,OAAO,EAAE;AACjB,MAAM,YAAY,GAAG,gBAAgB,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;AACpD,KAAK,MAAM,IAAI,YAAY,EAAE;AAC7B,MAAM,YAAY,GAAG,aAAa,CAAC,YAAY,CAAC,CAAC;AACjD,KAAK;AACL;AACA,IAAI,IAAI,YAAY,EAAE;AACtB,MAAM,IAAI,YAAY,KAAK,IAAI,CAAC,IAAI,EAAE;AACtC,QAAQ,MAAM,OAAO,GAAG,uBAAuB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AAC3D,QAAQ,OAAO,CAAC,WAAW;AAC3B,UAAU,IAAI,YAAY,CAAC,CAAC,kBAAkB,EAAE,OAAO,CAAC,OAAO,EAAE,QAAQ,CAAC,EAAE,CAAC,EAAE;AAC/E,YAAY,KAAK,EAAE,OAAO,GAAG,CAAC,OAAO,EAAE,IAAI,CAAC,GAAG,IAAI;AACnD,WAAW,CAAC;AACZ,SAAS,CAAC;AACV,OAAO;AACP,KAAK,MAAM;AACX,MAAM,MAAM,YAAY,GAAG,MAAM,CAAC,IAAI,CAAC;AACvC,QAAQ,GAAG,YAAY;AACvB,QAAQ,IAAI,MAAM,KAAK,IAAI,IAAI,MAAM,KAAK,KAAK,CAAC;AAChD,YAAY,KAAK,CAAC;AAClB,YAAY,MAAM,CAAC,UAAU,EAAE,CAAC;AAChC,OAAO,CAAC,CAAC;AACT,MAAM,MAAM,cAAc,GAAG,cAAc,CAAC,QAAQ,EAAE,YAAY,CAAC,CAAC;AACpE,MAAM,OAAO,CAAC,WAAW;AACzB,QAAQ,IAAI,YAAY;AACxB,UAAU,CAAC,oBAAoB,EAAE,QAAQ,CAAC,4BAA4B,CAAC;AACvE,YAAY,UAAU,CAAC,cAAc,CAAC;AACtC,UAAU;AACV,YAAY,KAAK,EAAE,IAAI,CAAC,IAAI;AAC5B,WAAW;AACX,SAAS;AACT,OAAO,CAAC;AACR,KAAK;AACL,GAAG;AACH,CAAC;AACD,MAAM,gBAAgB,GAAG;AACzB,EAAE,CAAC,IAAI,CAAC,sBAAsB,GAAG,IAAI,CAAC,qBAAqB;AAC3D,EAAE,CAAC,IAAI,CAAC,sBAAsB,GAAG,IAAI,CAAC,qBAAqB;AAC3D,EAAE,CAAC,IAAI,CAAC,yBAAyB,GAAG,IAAI,CAAC,wBAAwB;AACjE,EAAE,CAAC,IAAI,CAAC,qBAAqB,GAAG,IAAI,CAAC,oBAAoB;AACzD,EAAE,CAAC,IAAI,CAAC,oBAAoB,GAAG,IAAI,CAAC,mBAAmB;AACvD,EAAE,CAAC,IAAI,CAAC,4BAA4B,GAAG,IAAI,CAAC,2BAA2B;AACvE,CAAC,CAAC;AACF;AACA,SAAS,aAAa,CAAC,IAAI,EAAE;AAC7B,EAAE,IAAI,YAAY,CAAC,IAAI,CAAC,EAAE;AAC1B,IAAI,OAAO,IAAI,CAAC,qBAAqB,CAAC;AACtC,GAAG;AACH;AACA,EAAE,IAAI,YAAY,CAAC,IAAI,CAAC,EAAE;AAC1B,IAAI,OAAO,IAAI,CAAC,qBAAqB,CAAC;AACtC,GAAG;AACH;AACA,EAAE,IAAI,eAAe,CAAC,IAAI,CAAC,EAAE;AAC7B,IAAI,OAAO,IAAI,CAAC,wBAAwB,CAAC;AACzC,GAAG;AACH;AACA,EAAE,IAAI,WAAW,CAAC,IAAI,CAAC,EAAE;AACzB,IAAI,OAAO,IAAI,CAAC,oBAAoB,CAAC;AACrC,GAAG;AACH;AACA,EAAE,IAAI,UAAU,CAAC,IAAI,CAAC,EAAE;AACxB,IAAI,OAAO,IAAI,CAAC,mBAAmB,CAAC;AACpC,GAAG;AACH;AACA,EAAE,IAAI,iBAAiB,CAAC,IAAI,CAAC,EAAE;AAC/B,IAAI,OAAO,IAAI,CAAC,2BAA2B,CAAC;AAC5C,GAAG;AACH;AACA;AACA;AACA,EAAW,SAAS,CAAC,KAAK,EAAE,mBAAmB,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC;AACjE,CAAC;AACD;AACA,SAAS,uBAAuB,CAAC,IAAI,EAAE;AACvC,EAAE,QAAQ,IAAI;AACd,IAAI,KAAK,IAAI,CAAC,qBAAqB;AACnC,MAAM,OAAO,QAAQ,CAAC;AACtB;AACA,IAAI,KAAK,IAAI,CAAC,qBAAqB;AACnC,MAAM,OAAO,QAAQ,CAAC;AACtB;AACA,IAAI,KAAK,IAAI,CAAC,wBAAwB;AACtC,MAAM,OAAO,WAAW,CAAC;AACzB;AACA,IAAI,KAAK,IAAI,CAAC,oBAAoB;AAClC,MAAM,OAAO,OAAO,CAAC;AACrB;AACA,IAAI,KAAK,IAAI,CAAC,mBAAmB;AACjC,MAAM,OAAO,MAAM,CAAC;AACpB;AACA,IAAI,KAAK,IAAI,CAAC,2BAA2B;AACzC,MAAM,OAAO,cAAc,CAAC;AAC5B;AACA;AACA;AACA;AACA,IAAI;AACJ,MAAe,SAAS,CAAC,KAAK,EAAE,mBAAmB,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC;AACrE,GAAG;AACH;;;;"}