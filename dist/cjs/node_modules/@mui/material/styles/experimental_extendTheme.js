'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _extends = require('../../../@babel/runtime/helpers/esm/extends.js');
var objectWithoutPropertiesLoose = require('../../../@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js');
var deepmerge = require('../../utils/esm/deepmerge.js');
require('../../utils/esm/elementAcceptingRef.js');
require('../../utils/esm/elementTypeAcceptingRef.js');
require('react-is');
require('../../utils/esm/ponyfillGlobal.js');
require('../../utils/esm/refType.js');
require('react');
require('../../utils/esm/integerPropType.js');
require('@emotion/styled');
require('../../../@emotion/react/dist/emotion-react.esm.js');
require('../../styled-engine/StyledEngineProvider/StyledEngineProvider.js');
require('../../styled-engine/GlobalStyles/GlobalStyles.js');
require('../../system/esm/borders.js');
require('prop-types');
require('../../system/esm/display.js');
require('../../system/esm/flexbox.js');
require('../../system/esm/grid.js');
require('../../system/esm/palette.js');
require('../../system/esm/positions.js');
require('../../system/esm/shadows.js');
require('../../system/esm/sizing.js');
require('../../system/esm/spacing.js');
require('../../system/esm/responsivePropType.js');
require('../../system/esm/typography.js');
require('../../system/esm/styleFunctionSx/styleFunctionSx.js');
require('../../system/esm/getThemeValue.js');
require('../../system/esm/Box/Box.js');
require('../../system/esm/useTheme.js');
require('react/jsx-runtime');
require('../../system/esm/createStyled.js');
require('../../private-theming/ThemeProvider/ThemeProvider.js');
require('../../private-theming/useTheme/ThemeContext.js');
var colorManipulator = require('../../system/esm/colorManipulator.js');
require('../../system/esm/ThemeProvider/ThemeProvider.js');
require('../../system/esm/Container/createContainer.js');
require('../../system/esm/Container/Container.js');
require('../../system/esm/Container/containerClasses.js');
var createTheme = require('./createTheme.js');
var Paper = require('../Paper/Paper.js');

const _excluded = ["colorSchemes"],
      _excluded2 = ["palette"];
const defaultDarkOverlays = [...Array(25)].map((_, index) => {
  if (index === 0) {
    return undefined;
  }

  const overlay = Paper.getOverlayAlpha(index);
  return `linear-gradient(rgba(255 255 255 / ${overlay}), rgba(255 255 255 / ${overlay}))`;
});
function extendTheme(options = {}, ...args) {
  var _colorSchemesInput$li, _colorSchemesInput$da, _colorSchemesInput$li2, _colorSchemesInput$li3, _colorSchemesInput$da2, _colorSchemesInput$da3;

  const {
    colorSchemes: colorSchemesInput = {}
  } = options,
        input = objectWithoutPropertiesLoose["default"](options, _excluded);

  const _createThemeWithoutVa = createTheme["default"](_extends["default"]({}, input, colorSchemesInput.light && {
    palette: (_colorSchemesInput$li = colorSchemesInput.light) == null ? void 0 : _colorSchemesInput$li.palette
  })),
        {
    palette: lightPalette
  } = _createThemeWithoutVa,
        muiTheme = objectWithoutPropertiesLoose["default"](_createThemeWithoutVa, _excluded2);

  const {
    palette: darkPalette
  } = createTheme["default"]({
    palette: _extends["default"]({
      mode: 'dark'
    }, (_colorSchemesInput$da = colorSchemesInput.dark) == null ? void 0 : _colorSchemesInput$da.palette)
  });

  let theme = _extends["default"]({}, muiTheme, {
    colorSchemes: _extends["default"]({}, colorSchemesInput, {
      light: _extends["default"]({}, colorSchemesInput.light, {
        palette: lightPalette,
        opacity: _extends["default"]({
          placeholder: 0.42,
          inputTouchBottomLine: 0.42
        }, (_colorSchemesInput$li2 = colorSchemesInput.light) == null ? void 0 : _colorSchemesInput$li2.opacity),
        overlays: ((_colorSchemesInput$li3 = colorSchemesInput.light) == null ? void 0 : _colorSchemesInput$li3.overlays) || []
      }),
      dark: _extends["default"]({}, colorSchemesInput.dark, {
        palette: darkPalette,
        opacity: _extends["default"]({
          placeholder: 0.5,
          inputTouchBottomLine: 0.7
        }, (_colorSchemesInput$da2 = colorSchemesInput.dark) == null ? void 0 : _colorSchemesInput$da2.opacity),
        overlays: ((_colorSchemesInput$da3 = colorSchemesInput.dark) == null ? void 0 : _colorSchemesInput$da3.overlays) || defaultDarkOverlays
      })
    })
  });

  Object.keys(theme.colorSchemes).forEach(key => {
    const palette = theme.colorSchemes[key].palette; // attach black & white channels to common node

    if (key === 'dark') {
      palette.common.background = palette.common.background || '#000';
      palette.common.onBackground = palette.common.onBackground || '#fff';
    } else {
      palette.common.background = palette.common.background || '#fff';
      palette.common.onBackground = palette.common.onBackground || '#000';
    }

    palette.common.backgroundChannel = colorManipulator.colorChannel(palette.common.background);
    palette.common.onBackgroundChannel = colorManipulator.colorChannel(palette.common.onBackground);
    palette.dividerChannel = colorManipulator.colorChannel(palette.divider); // special token for Tooltip
    // TODO: consider adding `main`, and `light` to palette.grey to make it consistent.

    if (!palette.grey.dark) {
      palette.grey.dark = palette.grey[700];
    }

    Object.keys(palette).forEach(color => {
      const colors = palette[color]; // Color palettes: primary, secondary, error, info, success, and warning

      if (colors.main) {
        palette[color].mainChannel = colorManipulator.colorChannel(colors.main);
      }

      if (colors.light) {
        palette[color].lightChannel = colorManipulator.colorChannel(colors.light);
      }

      if (colors.dark) {
        palette[color].darkChannel = colorManipulator.colorChannel(colors.dark);
      }

      if (colors.contrastText) {
        palette[color].contrastTextChannel = colorManipulator.colorChannel(colors.contrastText);
      } // Text colors: text.primary, text.secondary


      if (colors.primary) {
        palette[color].primaryChannel = colorManipulator.colorChannel(colors.primary);
      }

      if (colors.secondary) {
        palette[color].secondaryChannel = colorManipulator.colorChannel(colors.secondary);
      } // Action colors: action.activeChannel


      if (colors.active) {
        palette[color].activeChannel = colorManipulator.colorChannel(colors.active);
      }
    });
  });
  theme = args.reduce((acc, argument) => deepmerge["default"](acc, argument), theme);
  return theme;
}

exports["default"] = extendTheme;
//# sourceMappingURL=experimental_extendTheme.js.map
