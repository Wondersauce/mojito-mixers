{"version":3,"file":"definition.mjs.js","sources":["../../../../../node_modules/graphql/type/definition.mjs"],"sourcesContent":["import { devAssert } from '../jsutils/devAssert.mjs';\nimport { didYouMean } from '../jsutils/didYouMean.mjs';\nimport { identityFunc } from '../jsutils/identityFunc.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { instanceOf } from '../jsutils/instanceOf.mjs';\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { keyMap } from '../jsutils/keyMap.mjs';\nimport { keyValMap } from '../jsutils/keyValMap.mjs';\nimport { mapValue } from '../jsutils/mapValue.mjs';\nimport { suggestionList } from '../jsutils/suggestionList.mjs';\nimport { toObjMap } from '../jsutils/toObjMap.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport { print } from '../language/printer.mjs';\nimport { valueFromASTUntyped } from '../utilities/valueFromASTUntyped.mjs';\nimport { assertEnumValueName, assertName } from './assertName.mjs';\nexport function isType(type) {\n  return (\n    isScalarType(type) ||\n    isObjectType(type) ||\n    isInterfaceType(type) ||\n    isUnionType(type) ||\n    isEnumType(type) ||\n    isInputObjectType(type) ||\n    isListType(type) ||\n    isNonNullType(type)\n  );\n}\nexport function assertType(type) {\n  if (!isType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL type.`);\n  }\n\n  return type;\n}\n/**\n * There are predicates for each kind of GraphQL type.\n */\n\nexport function isScalarType(type) {\n  return instanceOf(type, GraphQLScalarType);\n}\nexport function assertScalarType(type) {\n  if (!isScalarType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL Scalar type.`);\n  }\n\n  return type;\n}\nexport function isObjectType(type) {\n  return instanceOf(type, GraphQLObjectType);\n}\nexport function assertObjectType(type) {\n  if (!isObjectType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL Object type.`);\n  }\n\n  return type;\n}\nexport function isInterfaceType(type) {\n  return instanceOf(type, GraphQLInterfaceType);\n}\nexport function assertInterfaceType(type) {\n  if (!isInterfaceType(type)) {\n    throw new Error(\n      `Expected ${inspect(type)} to be a GraphQL Interface type.`,\n    );\n  }\n\n  return type;\n}\nexport function isUnionType(type) {\n  return instanceOf(type, GraphQLUnionType);\n}\nexport function assertUnionType(type) {\n  if (!isUnionType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL Union type.`);\n  }\n\n  return type;\n}\nexport function isEnumType(type) {\n  return instanceOf(type, GraphQLEnumType);\n}\nexport function assertEnumType(type) {\n  if (!isEnumType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL Enum type.`);\n  }\n\n  return type;\n}\nexport function isInputObjectType(type) {\n  return instanceOf(type, GraphQLInputObjectType);\n}\nexport function assertInputObjectType(type) {\n  if (!isInputObjectType(type)) {\n    throw new Error(\n      `Expected ${inspect(type)} to be a GraphQL Input Object type.`,\n    );\n  }\n\n  return type;\n}\nexport function isListType(type) {\n  return instanceOf(type, GraphQLList);\n}\nexport function assertListType(type) {\n  if (!isListType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL List type.`);\n  }\n\n  return type;\n}\nexport function isNonNullType(type) {\n  return instanceOf(type, GraphQLNonNull);\n}\nexport function assertNonNullType(type) {\n  if (!isNonNullType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL Non-Null type.`);\n  }\n\n  return type;\n}\n/**\n * These types may be used as input types for arguments and directives.\n */\n\nexport function isInputType(type) {\n  return (\n    isScalarType(type) ||\n    isEnumType(type) ||\n    isInputObjectType(type) ||\n    (isWrappingType(type) && isInputType(type.ofType))\n  );\n}\nexport function assertInputType(type) {\n  if (!isInputType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL input type.`);\n  }\n\n  return type;\n}\n/**\n * These types may be used as output types as the result of fields.\n */\n\nexport function isOutputType(type) {\n  return (\n    isScalarType(type) ||\n    isObjectType(type) ||\n    isInterfaceType(type) ||\n    isUnionType(type) ||\n    isEnumType(type) ||\n    (isWrappingType(type) && isOutputType(type.ofType))\n  );\n}\nexport function assertOutputType(type) {\n  if (!isOutputType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL output type.`);\n  }\n\n  return type;\n}\n/**\n * These types may describe types which may be leaf values.\n */\n\nexport function isLeafType(type) {\n  return isScalarType(type) || isEnumType(type);\n}\nexport function assertLeafType(type) {\n  if (!isLeafType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL leaf type.`);\n  }\n\n  return type;\n}\n/**\n * These types may describe the parent context of a selection set.\n */\n\nexport function isCompositeType(type) {\n  return isObjectType(type) || isInterfaceType(type) || isUnionType(type);\n}\nexport function assertCompositeType(type) {\n  if (!isCompositeType(type)) {\n    throw new Error(\n      `Expected ${inspect(type)} to be a GraphQL composite type.`,\n    );\n  }\n\n  return type;\n}\n/**\n * These types may describe the parent context of a selection set.\n */\n\nexport function isAbstractType(type) {\n  return isInterfaceType(type) || isUnionType(type);\n}\nexport function assertAbstractType(type) {\n  if (!isAbstractType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL abstract type.`);\n  }\n\n  return type;\n}\n/**\n * List Type Wrapper\n *\n * A list is a wrapping type which points to another type.\n * Lists are often created within the context of defining the fields of\n * an object type.\n *\n * Example:\n *\n * ```ts\n * const PersonType = new GraphQLObjectType({\n *   name: 'Person',\n *   fields: () => ({\n *     parents: { type: new GraphQLList(PersonType) },\n *     children: { type: new GraphQLList(PersonType) },\n *   })\n * })\n * ```\n */\n\nexport class GraphQLList {\n  constructor(ofType) {\n    isType(ofType) ||\n      devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL type.`);\n    this.ofType = ofType;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLList';\n  }\n\n  toString() {\n    return '[' + String(this.ofType) + ']';\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n}\n/**\n * Non-Null Type Wrapper\n *\n * A non-null is a wrapping type which points to another type.\n * Non-null types enforce that their values are never null and can ensure\n * an error is raised if this ever occurs during a request. It is useful for\n * fields which you can make a strong guarantee on non-nullability, for example\n * usually the id field of a database row will never be null.\n *\n * Example:\n *\n * ```ts\n * const RowType = new GraphQLObjectType({\n *   name: 'Row',\n *   fields: () => ({\n *     id: { type: new GraphQLNonNull(GraphQLString) },\n *   })\n * })\n * ```\n * Note: the enforcement of non-nullability occurs within the executor.\n */\n\nexport class GraphQLNonNull {\n  constructor(ofType) {\n    isNullableType(ofType) ||\n      devAssert(\n        false,\n        `Expected ${inspect(ofType)} to be a GraphQL nullable type.`,\n      );\n    this.ofType = ofType;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLNonNull';\n  }\n\n  toString() {\n    return String(this.ofType) + '!';\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n}\n/**\n * These types wrap and modify other types\n */\n\nexport function isWrappingType(type) {\n  return isListType(type) || isNonNullType(type);\n}\nexport function assertWrappingType(type) {\n  if (!isWrappingType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL wrapping type.`);\n  }\n\n  return type;\n}\n/**\n * These types can all accept null as a value.\n */\n\nexport function isNullableType(type) {\n  return isType(type) && !isNonNullType(type);\n}\nexport function assertNullableType(type) {\n  if (!isNullableType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL nullable type.`);\n  }\n\n  return type;\n}\nexport function getNullableType(type) {\n  if (type) {\n    return isNonNullType(type) ? type.ofType : type;\n  }\n}\n/**\n * These named types do not include modifiers like List or NonNull.\n */\n\nexport function isNamedType(type) {\n  return (\n    isScalarType(type) ||\n    isObjectType(type) ||\n    isInterfaceType(type) ||\n    isUnionType(type) ||\n    isEnumType(type) ||\n    isInputObjectType(type)\n  );\n}\nexport function assertNamedType(type) {\n  if (!isNamedType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL named type.`);\n  }\n\n  return type;\n}\nexport function getNamedType(type) {\n  if (type) {\n    let unwrappedType = type;\n\n    while (isWrappingType(unwrappedType)) {\n      unwrappedType = unwrappedType.ofType;\n    }\n\n    return unwrappedType;\n  }\n}\n/**\n * Used while defining GraphQL types to allow for circular references in\n * otherwise immutable type definitions.\n */\n\nexport function resolveReadonlyArrayThunk(thunk) {\n  return typeof thunk === 'function' ? thunk() : thunk;\n}\nexport function resolveObjMapThunk(thunk) {\n  return typeof thunk === 'function' ? thunk() : thunk;\n}\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\n\n/**\n * Scalar Type Definition\n *\n * The leaf values of any request and input values to arguments are\n * Scalars (or Enums) and are defined with a name and a series of functions\n * used to parse input from ast or variables and to ensure validity.\n *\n * If a type's serialize function returns `null` or does not return a value\n * (i.e. it returns `undefined`) then an error will be raised and a `null`\n * value will be returned in the response. It is always better to validate\n *\n * Example:\n *\n * ```ts\n * const OddType = new GraphQLScalarType({\n *   name: 'Odd',\n *   serialize(value) {\n *     if (!Number.isFinite(value)) {\n *       throw new Error(\n *         `Scalar \"Odd\" cannot represent \"${value}\" since it is not a finite number.`,\n *       );\n *     }\n *\n *     if (value % 2 === 0) {\n *       throw new Error(`Scalar \"Odd\" cannot represent \"${value}\" since it is even.`);\n *     }\n *     return value;\n *   }\n * });\n * ```\n */\nexport class GraphQLScalarType {\n  constructor(config) {\n    var _config$parseValue,\n      _config$serialize,\n      _config$parseLiteral,\n      _config$extensionASTN;\n\n    const parseValue =\n      (_config$parseValue = config.parseValue) !== null &&\n      _config$parseValue !== void 0\n        ? _config$parseValue\n        : identityFunc;\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.specifiedByURL = config.specifiedByURL;\n    this.serialize =\n      (_config$serialize = config.serialize) !== null &&\n      _config$serialize !== void 0\n        ? _config$serialize\n        : identityFunc;\n    this.parseValue = parseValue;\n    this.parseLiteral =\n      (_config$parseLiteral = config.parseLiteral) !== null &&\n      _config$parseLiteral !== void 0\n        ? _config$parseLiteral\n        : (node, variables) => parseValue(valueFromASTUntyped(node, variables));\n    this.extensions = toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes =\n      (_config$extensionASTN = config.extensionASTNodes) !== null &&\n      _config$extensionASTN !== void 0\n        ? _config$extensionASTN\n        : [];\n    config.specifiedByURL == null ||\n      typeof config.specifiedByURL === 'string' ||\n      devAssert(\n        false,\n        `${this.name} must provide \"specifiedByURL\" as a string, ` +\n          `but got: ${inspect(config.specifiedByURL)}.`,\n      );\n    config.serialize == null ||\n      typeof config.serialize === 'function' ||\n      devAssert(\n        false,\n        `${this.name} must provide \"serialize\" function. If this custom Scalar is also used as an input type, ensure \"parseValue\" and \"parseLiteral\" functions are also provided.`,\n      );\n\n    if (config.parseLiteral) {\n      (typeof config.parseValue === 'function' &&\n        typeof config.parseLiteral === 'function') ||\n        devAssert(\n          false,\n          `${this.name} must provide both \"parseValue\" and \"parseLiteral\" functions.`,\n        );\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLScalarType';\n  }\n\n  toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      specifiedByURL: this.specifiedByURL,\n      serialize: this.serialize,\n      parseValue: this.parseValue,\n      parseLiteral: this.parseLiteral,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n    };\n  }\n\n  toString() {\n    return this.name;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n}\n\n/**\n * Object Type Definition\n *\n * Almost all of the GraphQL types you define will be object types. Object types\n * have a name, but most importantly describe their fields.\n *\n * Example:\n *\n * ```ts\n * const AddressType = new GraphQLObjectType({\n *   name: 'Address',\n *   fields: {\n *     street: { type: GraphQLString },\n *     number: { type: GraphQLInt },\n *     formatted: {\n *       type: GraphQLString,\n *       resolve(obj) {\n *         return obj.number + ' ' + obj.street\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * When two types need to refer to each other, or a type needs to refer to\n * itself in a field, you can use a function expression (aka a closure or a\n * thunk) to supply the fields lazily.\n *\n * Example:\n *\n * ```ts\n * const PersonType = new GraphQLObjectType({\n *   name: 'Person',\n *   fields: () => ({\n *     name: { type: GraphQLString },\n *     bestFriend: { type: PersonType },\n *   })\n * });\n * ```\n */\nexport class GraphQLObjectType {\n  constructor(config) {\n    var _config$extensionASTN2;\n\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.isTypeOf = config.isTypeOf;\n    this.extensions = toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes =\n      (_config$extensionASTN2 = config.extensionASTNodes) !== null &&\n      _config$extensionASTN2 !== void 0\n        ? _config$extensionASTN2\n        : [];\n\n    this._fields = () => defineFieldMap(config);\n\n    this._interfaces = () => defineInterfaces(config);\n\n    config.isTypeOf == null ||\n      typeof config.isTypeOf === 'function' ||\n      devAssert(\n        false,\n        `${this.name} must provide \"isTypeOf\" as a function, ` +\n          `but got: ${inspect(config.isTypeOf)}.`,\n      );\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLObjectType';\n  }\n\n  getFields() {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n\n    return this._fields;\n  }\n\n  getInterfaces() {\n    if (typeof this._interfaces === 'function') {\n      this._interfaces = this._interfaces();\n    }\n\n    return this._interfaces;\n  }\n\n  toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      interfaces: this.getInterfaces(),\n      fields: fieldsToFieldsConfig(this.getFields()),\n      isTypeOf: this.isTypeOf,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n    };\n  }\n\n  toString() {\n    return this.name;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n}\n\nfunction defineInterfaces(config) {\n  var _config$interfaces;\n\n  const interfaces = resolveReadonlyArrayThunk(\n    (_config$interfaces = config.interfaces) !== null &&\n      _config$interfaces !== void 0\n      ? _config$interfaces\n      : [],\n  );\n  Array.isArray(interfaces) ||\n    devAssert(\n      false,\n      `${config.name} interfaces must be an Array or a function which returns an Array.`,\n    );\n  return interfaces;\n}\n\nfunction defineFieldMap(config) {\n  const fieldMap = resolveObjMapThunk(config.fields);\n  isPlainObj(fieldMap) ||\n    devAssert(\n      false,\n      `${config.name} fields must be an object with field names as keys or a function which returns such an object.`,\n    );\n  return mapValue(fieldMap, (fieldConfig, fieldName) => {\n    var _fieldConfig$args;\n\n    isPlainObj(fieldConfig) ||\n      devAssert(\n        false,\n        `${config.name}.${fieldName} field config must be an object.`,\n      );\n    fieldConfig.resolve == null ||\n      typeof fieldConfig.resolve === 'function' ||\n      devAssert(\n        false,\n        `${config.name}.${fieldName} field resolver must be a function if ` +\n          `provided, but got: ${inspect(fieldConfig.resolve)}.`,\n      );\n    const argsConfig =\n      (_fieldConfig$args = fieldConfig.args) !== null &&\n      _fieldConfig$args !== void 0\n        ? _fieldConfig$args\n        : {};\n    isPlainObj(argsConfig) ||\n      devAssert(\n        false,\n        `${config.name}.${fieldName} args must be an object with argument names as keys.`,\n      );\n    return {\n      name: assertName(fieldName),\n      description: fieldConfig.description,\n      type: fieldConfig.type,\n      args: defineArguments(argsConfig),\n      resolve: fieldConfig.resolve,\n      subscribe: fieldConfig.subscribe,\n      deprecationReason: fieldConfig.deprecationReason,\n      extensions: toObjMap(fieldConfig.extensions),\n      astNode: fieldConfig.astNode,\n    };\n  });\n}\n\nexport function defineArguments(config) {\n  return Object.entries(config).map(([argName, argConfig]) => ({\n    name: assertName(argName),\n    description: argConfig.description,\n    type: argConfig.type,\n    defaultValue: argConfig.defaultValue,\n    deprecationReason: argConfig.deprecationReason,\n    extensions: toObjMap(argConfig.extensions),\n    astNode: argConfig.astNode,\n  }));\n}\n\nfunction isPlainObj(obj) {\n  return isObjectLike(obj) && !Array.isArray(obj);\n}\n\nfunction fieldsToFieldsConfig(fields) {\n  return mapValue(fields, (field) => ({\n    description: field.description,\n    type: field.type,\n    args: argsToArgsConfig(field.args),\n    resolve: field.resolve,\n    subscribe: field.subscribe,\n    deprecationReason: field.deprecationReason,\n    extensions: field.extensions,\n    astNode: field.astNode,\n  }));\n}\n/**\n * @internal\n */\n\nexport function argsToArgsConfig(args) {\n  return keyValMap(\n    args,\n    (arg) => arg.name,\n    (arg) => ({\n      description: arg.description,\n      type: arg.type,\n      defaultValue: arg.defaultValue,\n      deprecationReason: arg.deprecationReason,\n      extensions: arg.extensions,\n      astNode: arg.astNode,\n    }),\n  );\n}\nexport function isRequiredArgument(arg) {\n  return isNonNullType(arg.type) && arg.defaultValue === undefined;\n}\n\n/**\n * Interface Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Interface type\n * is used to describe what types are possible, what fields are in common across\n * all types, as well as a function to determine which type is actually used\n * when the field is resolved.\n *\n * Example:\n *\n * ```ts\n * const EntityType = new GraphQLInterfaceType({\n *   name: 'Entity',\n *   fields: {\n *     name: { type: GraphQLString }\n *   }\n * });\n * ```\n */\nexport class GraphQLInterfaceType {\n  constructor(config) {\n    var _config$extensionASTN3;\n\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.resolveType = config.resolveType;\n    this.extensions = toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes =\n      (_config$extensionASTN3 = config.extensionASTNodes) !== null &&\n      _config$extensionASTN3 !== void 0\n        ? _config$extensionASTN3\n        : [];\n    this._fields = defineFieldMap.bind(undefined, config);\n    this._interfaces = defineInterfaces.bind(undefined, config);\n    config.resolveType == null ||\n      typeof config.resolveType === 'function' ||\n      devAssert(\n        false,\n        `${this.name} must provide \"resolveType\" as a function, ` +\n          `but got: ${inspect(config.resolveType)}.`,\n      );\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLInterfaceType';\n  }\n\n  getFields() {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n\n    return this._fields;\n  }\n\n  getInterfaces() {\n    if (typeof this._interfaces === 'function') {\n      this._interfaces = this._interfaces();\n    }\n\n    return this._interfaces;\n  }\n\n  toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      interfaces: this.getInterfaces(),\n      fields: fieldsToFieldsConfig(this.getFields()),\n      resolveType: this.resolveType,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n    };\n  }\n\n  toString() {\n    return this.name;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n}\n\n/**\n * Union Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Union type\n * is used to describe what types are possible as well as providing a function\n * to determine which type is actually used when the field is resolved.\n *\n * Example:\n *\n * ```ts\n * const PetType = new GraphQLUnionType({\n *   name: 'Pet',\n *   types: [ DogType, CatType ],\n *   resolveType(value) {\n *     if (value instanceof Dog) {\n *       return DogType;\n *     }\n *     if (value instanceof Cat) {\n *       return CatType;\n *     }\n *   }\n * });\n * ```\n */\nexport class GraphQLUnionType {\n  constructor(config) {\n    var _config$extensionASTN4;\n\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.resolveType = config.resolveType;\n    this.extensions = toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes =\n      (_config$extensionASTN4 = config.extensionASTNodes) !== null &&\n      _config$extensionASTN4 !== void 0\n        ? _config$extensionASTN4\n        : [];\n    this._types = defineTypes.bind(undefined, config);\n    config.resolveType == null ||\n      typeof config.resolveType === 'function' ||\n      devAssert(\n        false,\n        `${this.name} must provide \"resolveType\" as a function, ` +\n          `but got: ${inspect(config.resolveType)}.`,\n      );\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLUnionType';\n  }\n\n  getTypes() {\n    if (typeof this._types === 'function') {\n      this._types = this._types();\n    }\n\n    return this._types;\n  }\n\n  toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      types: this.getTypes(),\n      resolveType: this.resolveType,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n    };\n  }\n\n  toString() {\n    return this.name;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n}\n\nfunction defineTypes(config) {\n  const types = resolveReadonlyArrayThunk(config.types);\n  Array.isArray(types) ||\n    devAssert(\n      false,\n      `Must provide Array of types or a function which returns such an array for Union ${config.name}.`,\n    );\n  return types;\n}\n\n/**\n * Enum Type Definition\n *\n * Some leaf values of requests and input values are Enums. GraphQL serializes\n * Enum values as strings, however internally Enums can be represented by any\n * kind of type, often integers.\n *\n * Example:\n *\n * ```ts\n * const RGBType = new GraphQLEnumType({\n *   name: 'RGB',\n *   values: {\n *     RED: { value: 0 },\n *     GREEN: { value: 1 },\n *     BLUE: { value: 2 }\n *   }\n * });\n * ```\n *\n * Note: If a value is not provided in a definition, the name of the enum value\n * will be used as its internal value.\n */\nexport class GraphQLEnumType {\n  /* <T> */\n  constructor(config) {\n    var _config$extensionASTN5;\n\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.extensions = toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes =\n      (_config$extensionASTN5 = config.extensionASTNodes) !== null &&\n      _config$extensionASTN5 !== void 0\n        ? _config$extensionASTN5\n        : [];\n    this._values = defineEnumValues(this.name, config.values);\n    this._valueLookup = new Map(\n      this._values.map((enumValue) => [enumValue.value, enumValue]),\n    );\n    this._nameLookup = keyMap(this._values, (value) => value.name);\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLEnumType';\n  }\n\n  getValues() {\n    return this._values;\n  }\n\n  getValue(name) {\n    return this._nameLookup[name];\n  }\n\n  serialize(outputValue) {\n    const enumValue = this._valueLookup.get(outputValue);\n\n    if (enumValue === undefined) {\n      throw new GraphQLError(\n        `Enum \"${this.name}\" cannot represent value: ${inspect(outputValue)}`,\n      );\n    }\n\n    return enumValue.name;\n  }\n\n  parseValue(inputValue) /* T */\n  {\n    if (typeof inputValue !== 'string') {\n      const valueStr = inspect(inputValue);\n      throw new GraphQLError(\n        `Enum \"${this.name}\" cannot represent non-string value: ${valueStr}.` +\n          didYouMeanEnumValue(this, valueStr),\n      );\n    }\n\n    const enumValue = this.getValue(inputValue);\n\n    if (enumValue == null) {\n      throw new GraphQLError(\n        `Value \"${inputValue}\" does not exist in \"${this.name}\" enum.` +\n          didYouMeanEnumValue(this, inputValue),\n      );\n    }\n\n    return enumValue.value;\n  }\n\n  parseLiteral(valueNode, _variables) /* T */\n  {\n    // Note: variables will be resolved to a value before calling this function.\n    if (valueNode.kind !== Kind.ENUM) {\n      const valueStr = print(valueNode);\n      throw new GraphQLError(\n        `Enum \"${this.name}\" cannot represent non-enum value: ${valueStr}.` +\n          didYouMeanEnumValue(this, valueStr),\n        {\n          nodes: valueNode,\n        },\n      );\n    }\n\n    const enumValue = this.getValue(valueNode.value);\n\n    if (enumValue == null) {\n      const valueStr = print(valueNode);\n      throw new GraphQLError(\n        `Value \"${valueStr}\" does not exist in \"${this.name}\" enum.` +\n          didYouMeanEnumValue(this, valueStr),\n        {\n          nodes: valueNode,\n        },\n      );\n    }\n\n    return enumValue.value;\n  }\n\n  toConfig() {\n    const values = keyValMap(\n      this.getValues(),\n      (value) => value.name,\n      (value) => ({\n        description: value.description,\n        value: value.value,\n        deprecationReason: value.deprecationReason,\n        extensions: value.extensions,\n        astNode: value.astNode,\n      }),\n    );\n    return {\n      name: this.name,\n      description: this.description,\n      values,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n    };\n  }\n\n  toString() {\n    return this.name;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n}\n\nfunction didYouMeanEnumValue(enumType, unknownValueStr) {\n  const allNames = enumType.getValues().map((value) => value.name);\n  const suggestedValues = suggestionList(unknownValueStr, allNames);\n  return didYouMean('the enum value', suggestedValues);\n}\n\nfunction defineEnumValues(typeName, valueMap) {\n  isPlainObj(valueMap) ||\n    devAssert(\n      false,\n      `${typeName} values must be an object with value names as keys.`,\n    );\n  return Object.entries(valueMap).map(([valueName, valueConfig]) => {\n    isPlainObj(valueConfig) ||\n      devAssert(\n        false,\n        `${typeName}.${valueName} must refer to an object with a \"value\" key ` +\n          `representing an internal value but got: ${inspect(valueConfig)}.`,\n      );\n    return {\n      name: assertEnumValueName(valueName),\n      description: valueConfig.description,\n      value: valueConfig.value !== undefined ? valueConfig.value : valueName,\n      deprecationReason: valueConfig.deprecationReason,\n      extensions: toObjMap(valueConfig.extensions),\n      astNode: valueConfig.astNode,\n    };\n  });\n}\n\n/**\n * Input Object Type Definition\n *\n * An input object defines a structured collection of fields which may be\n * supplied to a field argument.\n *\n * Using `NonNull` will ensure that a value must be provided by the query\n *\n * Example:\n *\n * ```ts\n * const GeoPoint = new GraphQLInputObjectType({\n *   name: 'GeoPoint',\n *   fields: {\n *     lat: { type: new GraphQLNonNull(GraphQLFloat) },\n *     lon: { type: new GraphQLNonNull(GraphQLFloat) },\n *     alt: { type: GraphQLFloat, defaultValue: 0 },\n *   }\n * });\n * ```\n */\nexport class GraphQLInputObjectType {\n  constructor(config) {\n    var _config$extensionASTN6;\n\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.extensions = toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes =\n      (_config$extensionASTN6 = config.extensionASTNodes) !== null &&\n      _config$extensionASTN6 !== void 0\n        ? _config$extensionASTN6\n        : [];\n    this._fields = defineInputFieldMap.bind(undefined, config);\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLInputObjectType';\n  }\n\n  getFields() {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n\n    return this._fields;\n  }\n\n  toConfig() {\n    const fields = mapValue(this.getFields(), (field) => ({\n      description: field.description,\n      type: field.type,\n      defaultValue: field.defaultValue,\n      deprecationReason: field.deprecationReason,\n      extensions: field.extensions,\n      astNode: field.astNode,\n    }));\n    return {\n      name: this.name,\n      description: this.description,\n      fields,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n    };\n  }\n\n  toString() {\n    return this.name;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n}\n\nfunction defineInputFieldMap(config) {\n  const fieldMap = resolveObjMapThunk(config.fields);\n  isPlainObj(fieldMap) ||\n    devAssert(\n      false,\n      `${config.name} fields must be an object with field names as keys or a function which returns such an object.`,\n    );\n  return mapValue(fieldMap, (fieldConfig, fieldName) => {\n    !('resolve' in fieldConfig) ||\n      devAssert(\n        false,\n        `${config.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`,\n      );\n    return {\n      name: assertName(fieldName),\n      description: fieldConfig.description,\n      type: fieldConfig.type,\n      defaultValue: fieldConfig.defaultValue,\n      deprecationReason: fieldConfig.deprecationReason,\n      extensions: toObjMap(fieldConfig.extensions),\n      astNode: fieldConfig.astNode,\n    };\n  });\n}\n\nexport function isRequiredInputField(field) {\n  return isNonNullType(field.type) && field.defaultValue === undefined;\n}\n"],"names":["instanceOf","devAssert","inspect","identityFunc","assertName","valueFromASTUntyped","toObjMap","mapValue","isObjectLike","keyValMap","keyMap","GraphQLError","Kind","print","suggestionList","didYouMean","assertEnumValueName"],"mappings":"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"}