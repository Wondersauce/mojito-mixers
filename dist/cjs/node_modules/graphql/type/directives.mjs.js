'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var devAssert = require('../jsutils/devAssert.mjs.js');
require('../jsutils/instanceOf.mjs.js');
var isObjectLike = require('../jsutils/isObjectLike.mjs.js');
var toObjMap = require('../jsutils/toObjMap.mjs.js');
var directiveLocation = require('../language/directiveLocation.mjs.js');
var assertName = require('./assertName.mjs.js');
var definition = require('./definition.mjs.js');
var scalars = require('./scalars.mjs.js');

/**
 * Custom extensions
 *
 * @remarks
 * Use a unique identifier name for your extension, for example the name of
 * your library or project. Do not use a shortened identifier as this increases
 * the risk of conflicts. We recommend you add at most one extension field,
 * an object which can contain all the values you need.
 */

/**
 * Directives are used by the GraphQL runtime as a way of modifying execution
 * behavior. Type system creators will usually not create these directly.
 */
class GraphQLDirective {
  constructor(config) {
    var _config$isRepeatable, _config$args;

    this.name = assertName.assertName(config.name);
    this.description = config.description;
    this.locations = config.locations;
    this.isRepeatable =
      (_config$isRepeatable = config.isRepeatable) !== null &&
      _config$isRepeatable !== void 0
        ? _config$isRepeatable
        : false;
    this.extensions = toObjMap.toObjMap(config.extensions);
    this.astNode = config.astNode;
    Array.isArray(config.locations) ||
      devAssert.devAssert(false, `@${config.name} locations must be an Array.`);
    const args =
      (_config$args = config.args) !== null && _config$args !== void 0
        ? _config$args
        : {};
    (isObjectLike.isObjectLike(args) && !Array.isArray(args)) ||
      devAssert.devAssert(
        false,
        `@${config.name} args must be an object with argument names as keys.`,
      );
    this.args = definition.defineArguments(args);
  }

  get [Symbol.toStringTag]() {
    return 'GraphQLDirective';
  }

  toConfig() {
    return {
      name: this.name,
      description: this.description,
      locations: this.locations,
      args: definition.argsToArgsConfig(this.args),
      isRepeatable: this.isRepeatable,
      extensions: this.extensions,
      astNode: this.astNode,
    };
  }

  toString() {
    return '@' + this.name;
  }

  toJSON() {
    return this.toString();
  }
}

/**
 * Used to conditionally include fields or fragments.
 */
const GraphQLIncludeDirective = new GraphQLDirective({
  name: 'include',
  description:
    'Directs the executor to include this field or fragment only when the `if` argument is true.',
  locations: [
    directiveLocation.DirectiveLocation.FIELD,
    directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
    directiveLocation.DirectiveLocation.INLINE_FRAGMENT,
  ],
  args: {
    if: {
      type: new definition.GraphQLNonNull(scalars.GraphQLBoolean),
      description: 'Included when true.',
    },
  },
});
/**
 * Used to conditionally skip (exclude) fields or fragments.
 */

const GraphQLSkipDirective = new GraphQLDirective({
  name: 'skip',
  description:
    'Directs the executor to skip this field or fragment when the `if` argument is true.',
  locations: [
    directiveLocation.DirectiveLocation.FIELD,
    directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
    directiveLocation.DirectiveLocation.INLINE_FRAGMENT,
  ],
  args: {
    if: {
      type: new definition.GraphQLNonNull(scalars.GraphQLBoolean),
      description: 'Skipped when true.',
    },
  },
});
/**
 * Constant string used for default reason for a deprecation.
 */

const DEFAULT_DEPRECATION_REASON = 'No longer supported';
/**
 * Used to declare element of a GraphQL schema as deprecated.
 */

const GraphQLDeprecatedDirective = new GraphQLDirective({
  name: 'deprecated',
  description: 'Marks an element of a GraphQL schema as no longer supported.',
  locations: [
    directiveLocation.DirectiveLocation.FIELD_DEFINITION,
    directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION,
    directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION,
    directiveLocation.DirectiveLocation.ENUM_VALUE,
  ],
  args: {
    reason: {
      type: scalars.GraphQLString,
      description:
        'Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).',
      defaultValue: DEFAULT_DEPRECATION_REASON,
    },
  },
});
/**
 * Used to provide a URL for specifying the behavior of custom scalar definitions.
 */

const GraphQLSpecifiedByDirective = new GraphQLDirective({
  name: 'specifiedBy',
  description: 'Exposes a URL that specifies the behavior of this scalar.',
  locations: [directiveLocation.DirectiveLocation.SCALAR],
  args: {
    url: {
      type: new definition.GraphQLNonNull(scalars.GraphQLString),
      description: 'The URL that specifies the behavior of this scalar.',
    },
  },
});
/**
 * The full list of specified directives.
 */

const specifiedDirectives = Object.freeze([
  GraphQLIncludeDirective,
  GraphQLSkipDirective,
  GraphQLDeprecatedDirective,
  GraphQLSpecifiedByDirective,
]);

exports.DEFAULT_DEPRECATION_REASON = DEFAULT_DEPRECATION_REASON;
exports.GraphQLDeprecatedDirective = GraphQLDeprecatedDirective;
exports.GraphQLDirective = GraphQLDirective;
exports.GraphQLIncludeDirective = GraphQLIncludeDirective;
exports.GraphQLSkipDirective = GraphQLSkipDirective;
exports.GraphQLSpecifiedByDirective = GraphQLSpecifiedByDirective;
exports.specifiedDirectives = specifiedDirectives;
//# sourceMappingURL=directives.mjs.js.map
