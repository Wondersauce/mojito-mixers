'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var GraphQLError = require('../../error/GraphQLError.mjs.js');
var printer = require('../../language/printer.mjs.js');
var definition = require('../../type/definition.mjs.js');
var typeFromAST = require('../../utilities/typeFromAST.mjs.js');

/**
 * Fragments on composite type
 *
 * Fragments use a type condition to determine if they apply, since fragments
 * can only be spread into a composite type (object, interface, or union), the
 * type condition must also be a composite type.
 *
 * See https://spec.graphql.org/draft/#sec-Fragments-On-Composite-Types
 */
function FragmentsOnCompositeTypesRule(context) {
  return {
    InlineFragment(node) {
      const typeCondition = node.typeCondition;

      if (typeCondition) {
        const type = typeFromAST.typeFromAST(context.getSchema(), typeCondition);

        if (type && !definition.isCompositeType(type)) {
          const typeStr = printer.print(typeCondition);
          context.reportError(
            new GraphQLError.GraphQLError(
              `Fragment cannot condition on non composite type "${typeStr}".`,
              {
                nodes: typeCondition,
              },
            ),
          );
        }
      }
    },

    FragmentDefinition(node) {
      const type = typeFromAST.typeFromAST(context.getSchema(), node.typeCondition);

      if (type && !definition.isCompositeType(type)) {
        const typeStr = printer.print(node.typeCondition);
        context.reportError(
          new GraphQLError.GraphQLError(
            `Fragment "${node.name.value}" cannot condition on non composite type "${typeStr}".`,
            {
              nodes: node.typeCondition,
            },
          ),
        );
      }
    },
  };
}

exports.FragmentsOnCompositeTypesRule = FragmentsOnCompositeTypesRule;
//# sourceMappingURL=FragmentsOnCompositeTypesRule.mjs.js.map
