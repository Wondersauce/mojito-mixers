'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var didYouMean = require('../../jsutils/didYouMean.mjs.js');
var inspect = require('../../jsutils/inspect.mjs.js');
var invariant = require('../../jsutils/invariant.mjs.js');
var suggestionList = require('../../jsutils/suggestionList.mjs.js');
var GraphQLError = require('../../error/GraphQLError.mjs.js');
var kinds = require('../../language/kinds.mjs.js');
var predicates = require('../../language/predicates.mjs.js');
var definition = require('../../type/definition.mjs.js');

/**
 * Possible type extension
 *
 * A type extension is only valid if the type is defined and has the same kind.
 */
function PossibleTypeExtensionsRule(context) {
  const schema = context.getSchema();
  const definedTypes = Object.create(null);

  for (const def of context.getDocument().definitions) {
    if (predicates.isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = def;
    }
  }

  return {
    ScalarTypeExtension: checkExtension,
    ObjectTypeExtension: checkExtension,
    InterfaceTypeExtension: checkExtension,
    UnionTypeExtension: checkExtension,
    EnumTypeExtension: checkExtension,
    InputObjectTypeExtension: checkExtension,
  };

  function checkExtension(node) {
    const typeName = node.name.value;
    const defNode = definedTypes[typeName];
    const existingType =
      schema === null || schema === void 0 ? void 0 : schema.getType(typeName);
    let expectedKind;

    if (defNode) {
      expectedKind = defKindToExtKind[defNode.kind];
    } else if (existingType) {
      expectedKind = typeToExtKind(existingType);
    }

    if (expectedKind) {
      if (expectedKind !== node.kind) {
        const kindStr = extensionKindToTypeName(node.kind);
        context.reportError(
          new GraphQLError.GraphQLError(`Cannot extend non-${kindStr} type "${typeName}".`, {
            nodes: defNode ? [defNode, node] : node,
          }),
        );
      }
    } else {
      const allTypeNames = Object.keys({
        ...definedTypes,
        ...(schema === null || schema === void 0
          ? void 0
          : schema.getTypeMap()),
      });
      const suggestedTypes = suggestionList.suggestionList(typeName, allTypeNames);
      context.reportError(
        new GraphQLError.GraphQLError(
          `Cannot extend type "${typeName}" because it is not defined.` +
            didYouMean.didYouMean(suggestedTypes),
          {
            nodes: node.name,
          },
        ),
      );
    }
  }
}
const defKindToExtKind = {
  [kinds.Kind.SCALAR_TYPE_DEFINITION]: kinds.Kind.SCALAR_TYPE_EXTENSION,
  [kinds.Kind.OBJECT_TYPE_DEFINITION]: kinds.Kind.OBJECT_TYPE_EXTENSION,
  [kinds.Kind.INTERFACE_TYPE_DEFINITION]: kinds.Kind.INTERFACE_TYPE_EXTENSION,
  [kinds.Kind.UNION_TYPE_DEFINITION]: kinds.Kind.UNION_TYPE_EXTENSION,
  [kinds.Kind.ENUM_TYPE_DEFINITION]: kinds.Kind.ENUM_TYPE_EXTENSION,
  [kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION]: kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION,
};

function typeToExtKind(type) {
  if (definition.isScalarType(type)) {
    return kinds.Kind.SCALAR_TYPE_EXTENSION;
  }

  if (definition.isObjectType(type)) {
    return kinds.Kind.OBJECT_TYPE_EXTENSION;
  }

  if (definition.isInterfaceType(type)) {
    return kinds.Kind.INTERFACE_TYPE_EXTENSION;
  }

  if (definition.isUnionType(type)) {
    return kinds.Kind.UNION_TYPE_EXTENSION;
  }

  if (definition.isEnumType(type)) {
    return kinds.Kind.ENUM_TYPE_EXTENSION;
  }

  if (definition.isInputObjectType(type)) {
    return kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION;
  }
  /* c8 ignore next 3 */
  // Not reachable. All possible types have been considered

  invariant.invariant(false, 'Unexpected type: ' + inspect.inspect(type));
}

function extensionKindToTypeName(kind) {
  switch (kind) {
    case kinds.Kind.SCALAR_TYPE_EXTENSION:
      return 'scalar';

    case kinds.Kind.OBJECT_TYPE_EXTENSION:
      return 'object';

    case kinds.Kind.INTERFACE_TYPE_EXTENSION:
      return 'interface';

    case kinds.Kind.UNION_TYPE_EXTENSION:
      return 'union';

    case kinds.Kind.ENUM_TYPE_EXTENSION:
      return 'enum';

    case kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return 'input object';
    // Not reachable. All possible types have been considered

    /* c8 ignore next */

    default:
      invariant.invariant(false, 'Unexpected kind: ' + inspect.inspect(kind));
  }
}

exports.PossibleTypeExtensionsRule = PossibleTypeExtensionsRule;
//# sourceMappingURL=PossibleTypeExtensionsRule.mjs.js.map
