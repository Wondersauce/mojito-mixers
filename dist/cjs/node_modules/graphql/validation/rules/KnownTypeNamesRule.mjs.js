'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var didYouMean = require('../../jsutils/didYouMean.mjs.js');
var suggestionList = require('../../jsutils/suggestionList.mjs.js');
var GraphQLError = require('../../error/GraphQLError.mjs.js');
var predicates = require('../../language/predicates.mjs.js');
var introspection = require('../../type/introspection.mjs.js');
var scalars = require('../../type/scalars.mjs.js');

/**
 * Known type names
 *
 * A GraphQL document is only valid if referenced types (specifically
 * variable definitions and fragment conditions) are defined by the type schema.
 *
 * See https://spec.graphql.org/draft/#sec-Fragment-Spread-Type-Existence
 */
function KnownTypeNamesRule(context) {
  const schema = context.getSchema();
  const existingTypesMap = schema ? schema.getTypeMap() : Object.create(null);
  const definedTypes = Object.create(null);

  for (const def of context.getDocument().definitions) {
    if (predicates.isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = true;
    }
  }

  const typeNames = [
    ...Object.keys(existingTypesMap),
    ...Object.keys(definedTypes),
  ];
  return {
    NamedType(node, _1, parent, _2, ancestors) {
      const typeName = node.name.value;

      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
        var _ancestors$;

        const definitionNode =
          (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0
            ? _ancestors$
            : parent;
        const isSDL = definitionNode != null && isSDLNode(definitionNode);

        if (isSDL && standardTypeNames.includes(typeName)) {
          return;
        }

        const suggestedTypes = suggestionList.suggestionList(
          typeName,
          isSDL ? standardTypeNames.concat(typeNames) : typeNames,
        );
        context.reportError(
          new GraphQLError.GraphQLError(
            `Unknown type "${typeName}".` + didYouMean.didYouMean(suggestedTypes),
            {
              nodes: node,
            },
          ),
        );
      }
    },
  };
}
const standardTypeNames = [...scalars.specifiedScalarTypes, ...introspection.introspectionTypes].map(
  (type) => type.name,
);

function isSDLNode(value) {
  return (
    'kind' in value &&
    (predicates.isTypeSystemDefinitionNode(value) || predicates.isTypeSystemExtensionNode(value))
  );
}

exports.KnownTypeNamesRule = KnownTypeNamesRule;
//# sourceMappingURL=KnownTypeNamesRule.mjs.js.map
