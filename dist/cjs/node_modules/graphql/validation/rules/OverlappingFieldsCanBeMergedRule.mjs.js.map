{"version":3,"file":"OverlappingFieldsCanBeMergedRule.mjs.js","sources":["../../../../../../node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs"],"sourcesContent":["import { inspect } from '../../jsutils/inspect.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { print } from '../../language/printer.mjs';\nimport {\n  getNamedType,\n  isInterfaceType,\n  isLeafType,\n  isListType,\n  isNonNullType,\n  isObjectType,\n} from '../../type/definition.mjs';\nimport { sortValueNode } from '../../utilities/sortValueNode.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\nfunction reasonMessage(reason) {\n  if (Array.isArray(reason)) {\n    return reason\n      .map(\n        ([responseName, subReason]) =>\n          `subfields \"${responseName}\" conflict because ` +\n          reasonMessage(subReason),\n      )\n      .join(' and ');\n  }\n\n  return reason;\n}\n/**\n * Overlapping fields can be merged\n *\n * A selection set is only valid if all fields (including spreading any\n * fragments) either correspond to distinct response names or can be merged\n * without ambiguity.\n *\n * See https://spec.graphql.org/draft/#sec-Field-Selection-Merging\n */\n\nexport function OverlappingFieldsCanBeMergedRule(context) {\n  // A memoization for when two fragments are compared \"between\" each other for\n  // conflicts. Two fragments may be compared many times, so memoizing this can\n  // dramatically improve the performance of this validator.\n  const comparedFragmentPairs = new PairSet(); // A cache for the \"field map\" and list of fragment names found in any given\n  // selection set. Selection sets may be asked for this information multiple\n  // times, so this improves the performance of this validator.\n\n  const cachedFieldsAndFragmentNames = new Map();\n  return {\n    SelectionSet(selectionSet) {\n      const conflicts = findConflictsWithinSelectionSet(\n        context,\n        cachedFieldsAndFragmentNames,\n        comparedFragmentPairs,\n        context.getParentType(),\n        selectionSet,\n      );\n\n      for (const [[responseName, reason], fields1, fields2] of conflicts) {\n        const reasonMsg = reasonMessage(reason);\n        context.reportError(\n          new GraphQLError(\n            `Fields \"${responseName}\" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,\n            {\n              nodes: fields1.concat(fields2),\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n\n/**\n * Algorithm:\n *\n * Conflicts occur when two fields exist in a query which will produce the same\n * response name, but represent differing values, thus creating a conflict.\n * The algorithm below finds all conflicts via making a series of comparisons\n * between fields. In order to compare as few fields as possible, this makes\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\n *\n * Given any selection set, a collection produces both a set of fields by\n * also including all inline fragments, as well as a list of fragments\n * referenced by fragment spreads.\n *\n * A) Each selection set represented in the document first compares \"within\" its\n * collected set of fields, finding any conflicts between every pair of\n * overlapping fields.\n * Note: This is the *only time* that a the fields \"within\" a set are compared\n * to each other. After this only fields \"between\" sets are compared.\n *\n * B) Also, if any fragment is referenced in a selection set, then a\n * comparison is made \"between\" the original set of fields and the\n * referenced fragment.\n *\n * C) Also, if multiple fragments are referenced, then comparisons\n * are made \"between\" each referenced fragment.\n *\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\n * a comparison is made between each field in the original set of fields and\n * each field in the the referenced set of fields.\n *\n * E) Also, if any fragment is referenced in the referenced selection set,\n * then a comparison is made \"between\" the original set of fields and the\n * referenced fragment (recursively referring to step D).\n *\n * F) When comparing \"between\" two fragments, first a comparison is made between\n * each field in the first referenced set of fields and each field in the the\n * second referenced set of fields.\n *\n * G) Also, any fragments referenced by the first must be compared to the\n * second, and any fragments referenced by the second must be compared to the\n * first (recursively referring to step F).\n *\n * H) When comparing two fields, if both have selection sets, then a comparison\n * is made \"between\" both selection sets, first comparing the set of fields in\n * the first selection set with the set of fields in the second.\n *\n * I) Also, if any fragment is referenced in either selection set, then a\n * comparison is made \"between\" the other set of fields and the\n * referenced fragment.\n *\n * J) Also, if two fragments are referenced in both selection sets, then a\n * comparison is made \"between\" the two fragments.\n *\n */\n// Find all conflicts found \"within\" a selection set, including those found\n// via spreading in fragments. Called when visiting each SelectionSet in the\n// GraphQL Document.\nfunction findConflictsWithinSelectionSet(\n  context,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  parentType,\n  selectionSet,\n) {\n  const conflicts = [];\n  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType,\n    selectionSet,\n  ); // (A) Find find all conflicts \"within\" the fields of this selection set.\n  // Note: this is the *only place* `collectConflictsWithin` is called.\n\n  collectConflictsWithin(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    fieldMap,\n  );\n\n  if (fragmentNames.length !== 0) {\n    // (B) Then collect conflicts between these fields and those represented by\n    // each spread fragment name found.\n    for (let i = 0; i < fragmentNames.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(\n        context,\n        conflicts,\n        cachedFieldsAndFragmentNames,\n        comparedFragmentPairs,\n        false,\n        fieldMap,\n        fragmentNames[i],\n      ); // (C) Then compare this fragment with all other fragments found in this\n      // selection set to collect conflicts between fragments spread together.\n      // This compares each item in the list of fragment names to every other\n      // item in that same list (except for itself).\n\n      for (let j = i + 1; j < fragmentNames.length; j++) {\n        collectConflictsBetweenFragments(\n          context,\n          conflicts,\n          cachedFieldsAndFragmentNames,\n          comparedFragmentPairs,\n          false,\n          fragmentNames[i],\n          fragmentNames[j],\n        );\n      }\n    }\n  }\n\n  return conflicts;\n} // Collect all conflicts found between a set of fields and a fragment reference\n// including via spreading in any nested fragments.\n\nfunction collectConflictsBetweenFieldsAndFragment(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  areMutuallyExclusive,\n  fieldMap,\n  fragmentName,\n) {\n  const fragment = context.getFragment(fragmentName);\n\n  if (!fragment) {\n    return;\n  }\n\n  const [fieldMap2, referencedFragmentNames] =\n    getReferencedFieldsAndFragmentNames(\n      context,\n      cachedFieldsAndFragmentNames,\n      fragment,\n    ); // Do not compare a fragment's fieldMap to itself.\n\n  if (fieldMap === fieldMap2) {\n    return;\n  } // (D) First collect any conflicts between the provided collection of fields\n  // and the collection of fields represented by the given fragment.\n\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap,\n    fieldMap2,\n  ); // (E) Then collect any conflicts between the provided collection of fields\n  // and any fragment names found in the given fragment.\n\n  for (const referencedFragmentName of referencedFragmentNames) {\n    // Memoize so two fragments are not compared for conflicts more than once.\n    if (\n      comparedFragmentPairs.has(\n        referencedFragmentName,\n        fragmentName,\n        areMutuallyExclusive,\n      )\n    ) {\n      continue;\n    }\n\n    comparedFragmentPairs.add(\n      referencedFragmentName,\n      fragmentName,\n      areMutuallyExclusive,\n    );\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap,\n      referencedFragmentName,\n    );\n  }\n} // Collect all conflicts found between two fragments, including via spreading in\n// any nested fragments.\n\nfunction collectConflictsBetweenFragments(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  areMutuallyExclusive,\n  fragmentName1,\n  fragmentName2,\n) {\n  // No need to compare a fragment to itself.\n  if (fragmentName1 === fragmentName2) {\n    return;\n  } // Memoize so two fragments are not compared for conflicts more than once.\n\n  if (\n    comparedFragmentPairs.has(\n      fragmentName1,\n      fragmentName2,\n      areMutuallyExclusive,\n    )\n  ) {\n    return;\n  }\n\n  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);\n  const fragment1 = context.getFragment(fragmentName1);\n  const fragment2 = context.getFragment(fragmentName2);\n\n  if (!fragment1 || !fragment2) {\n    return;\n  }\n\n  const [fieldMap1, referencedFragmentNames1] =\n    getReferencedFieldsAndFragmentNames(\n      context,\n      cachedFieldsAndFragmentNames,\n      fragment1,\n    );\n  const [fieldMap2, referencedFragmentNames2] =\n    getReferencedFieldsAndFragmentNames(\n      context,\n      cachedFieldsAndFragmentNames,\n      fragment2,\n    ); // (F) First, collect all conflicts between these two collections of fields\n  // (not including any nested fragments).\n\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap1,\n    fieldMap2,\n  ); // (G) Then collect conflicts between the first fragment and any nested\n  // fragments spread in the second fragment.\n\n  for (const referencedFragmentName2 of referencedFragmentNames2) {\n    collectConflictsBetweenFragments(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fragmentName1,\n      referencedFragmentName2,\n    );\n  } // (G) Then collect conflicts between the second fragment and any nested\n  // fragments spread in the first fragment.\n\n  for (const referencedFragmentName1 of referencedFragmentNames1) {\n    collectConflictsBetweenFragments(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      referencedFragmentName1,\n      fragmentName2,\n    );\n  }\n} // Find all conflicts found between two selection sets, including those found\n// via spreading in fragments. Called when determining if conflicts exist\n// between the sub-fields of two overlapping fields.\n\nfunction findConflictsBetweenSubSelectionSets(\n  context,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  areMutuallyExclusive,\n  parentType1,\n  selectionSet1,\n  parentType2,\n  selectionSet2,\n) {\n  const conflicts = [];\n  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType1,\n    selectionSet1,\n  );\n  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType2,\n    selectionSet2,\n  ); // (H) First, collect all conflicts between these two collections of field.\n\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap1,\n    fieldMap2,\n  ); // (I) Then collect conflicts between the first collection of fields and\n  // those referenced by each fragment name associated with the second.\n\n  for (const fragmentName2 of fragmentNames2) {\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap1,\n      fragmentName2,\n    );\n  } // (I) Then collect conflicts between the second collection of fields and\n  // those referenced by each fragment name associated with the first.\n\n  for (const fragmentName1 of fragmentNames1) {\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap2,\n      fragmentName1,\n    );\n  } // (J) Also collect conflicts between any fragment names by the first and\n  // fragment names by the second. This compares each item in the first set of\n  // names to each item in the second set of names.\n\n  for (const fragmentName1 of fragmentNames1) {\n    for (const fragmentName2 of fragmentNames2) {\n      collectConflictsBetweenFragments(\n        context,\n        conflicts,\n        cachedFieldsAndFragmentNames,\n        comparedFragmentPairs,\n        areMutuallyExclusive,\n        fragmentName1,\n        fragmentName2,\n      );\n    }\n  }\n\n  return conflicts;\n} // Collect all Conflicts \"within\" one collection of fields.\n\nfunction collectConflictsWithin(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  fieldMap,\n) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For every response name, if there are multiple fields, they\n  // must be compared to find a potential conflict.\n  for (const [responseName, fields] of Object.entries(fieldMap)) {\n    // This compares every field in the list to every other field in this list\n    // (except to itself). If the list only has one item, nothing needs to\n    // be compared.\n    if (fields.length > 1) {\n      for (let i = 0; i < fields.length; i++) {\n        for (let j = i + 1; j < fields.length; j++) {\n          const conflict = findConflict(\n            context,\n            cachedFieldsAndFragmentNames,\n            comparedFragmentPairs,\n            false, // within one collection is never mutually exclusive\n            responseName,\n            fields[i],\n            fields[j],\n          );\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Collect all Conflicts between two collections of fields. This is similar to,\n// but different from the `collectConflictsWithin` function above. This check\n// assumes that `collectConflictsWithin` has already been called on each\n// provided collection of fields. This is true because this validator traverses\n// each individual selection set.\n\nfunction collectConflictsBetween(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  parentFieldsAreMutuallyExclusive,\n  fieldMap1,\n  fieldMap2,\n) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For any response name which appears in both provided field\n  // maps, each field from the first field map must be compared to every field\n  // in the second field map to find potential conflicts.\n  for (const [responseName, fields1] of Object.entries(fieldMap1)) {\n    const fields2 = fieldMap2[responseName];\n\n    if (fields2) {\n      for (const field1 of fields1) {\n        for (const field2 of fields2) {\n          const conflict = findConflict(\n            context,\n            cachedFieldsAndFragmentNames,\n            comparedFragmentPairs,\n            parentFieldsAreMutuallyExclusive,\n            responseName,\n            field1,\n            field2,\n          );\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Determines if there is a conflict between two particular fields, including\n// comparing their sub-fields.\n\nfunction findConflict(\n  context,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  parentFieldsAreMutuallyExclusive,\n  responseName,\n  field1,\n  field2,\n) {\n  const [parentType1, node1, def1] = field1;\n  const [parentType2, node2, def2] = field2; // If it is known that two fields could not possibly apply at the same\n  // time, due to the parent types, then it is safe to permit them to diverge\n  // in aliased field or arguments used as they will not present any ambiguity\n  // by differing.\n  // It is known that two parent types could never overlap if they are\n  // different Object types. Interface or Union types might overlap - if not\n  // in the current state of the schema, then perhaps in some future version,\n  // thus may not safely diverge.\n\n  const areMutuallyExclusive =\n    parentFieldsAreMutuallyExclusive ||\n    (parentType1 !== parentType2 &&\n      isObjectType(parentType1) &&\n      isObjectType(parentType2));\n\n  if (!areMutuallyExclusive) {\n    // Two aliases must refer to the same field.\n    const name1 = node1.name.value;\n    const name2 = node2.name.value;\n\n    if (name1 !== name2) {\n      return [\n        [responseName, `\"${name1}\" and \"${name2}\" are different fields`],\n        [node1],\n        [node2],\n      ];\n    } // Two field calls must have the same arguments.\n\n    if (stringifyArguments(node1) !== stringifyArguments(node2)) {\n      return [\n        [responseName, 'they have differing arguments'],\n        [node1],\n        [node2],\n      ];\n    }\n  } // The return type for each field.\n\n  const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;\n  const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;\n\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\n    return [\n      [\n        responseName,\n        `they return conflicting types \"${inspect(type1)}\" and \"${inspect(\n          type2,\n        )}\"`,\n      ],\n      [node1],\n      [node2],\n    ];\n  } // Collect and compare sub-fields. Use the same \"visited fragment names\" list\n  // for both collections so fields in a fragment reference are never\n  // compared to themselves.\n\n  const selectionSet1 = node1.selectionSet;\n  const selectionSet2 = node2.selectionSet;\n\n  if (selectionSet1 && selectionSet2) {\n    const conflicts = findConflictsBetweenSubSelectionSets(\n      context,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      getNamedType(type1),\n      selectionSet1,\n      getNamedType(type2),\n      selectionSet2,\n    );\n    return subfieldConflicts(conflicts, responseName, node1, node2);\n  }\n}\n\nfunction stringifyArguments(fieldNode) {\n  var _fieldNode$arguments;\n\n  // FIXME https://github.com/graphql/graphql-js/issues/2203\n  const args =\n    /* c8 ignore next */\n    (_fieldNode$arguments = fieldNode.arguments) !== null &&\n    _fieldNode$arguments !== void 0\n      ? _fieldNode$arguments\n      : [];\n  const inputObjectWithArgs = {\n    kind: Kind.OBJECT,\n    fields: args.map((argNode) => ({\n      kind: Kind.OBJECT_FIELD,\n      name: argNode.name,\n      value: argNode.value,\n    })),\n  };\n  return print(sortValueNode(inputObjectWithArgs));\n} // Two types conflict if both types could not apply to a value simultaneously.\n// Composite types are ignored as their individual field types will be compared\n// later recursively. However List and Non-Null types must match.\n\nfunction doTypesConflict(type1, type2) {\n  if (isListType(type1)) {\n    return isListType(type2)\n      ? doTypesConflict(type1.ofType, type2.ofType)\n      : true;\n  }\n\n  if (isListType(type2)) {\n    return true;\n  }\n\n  if (isNonNullType(type1)) {\n    return isNonNullType(type2)\n      ? doTypesConflict(type1.ofType, type2.ofType)\n      : true;\n  }\n\n  if (isNonNullType(type2)) {\n    return true;\n  }\n\n  if (isLeafType(type1) || isLeafType(type2)) {\n    return type1 !== type2;\n  }\n\n  return false;\n} // Given a selection set, return the collection of fields (a mapping of response\n// name to field nodes and definitions) as well as a list of fragment names\n// referenced via fragment spreads.\n\nfunction getFieldsAndFragmentNames(\n  context,\n  cachedFieldsAndFragmentNames,\n  parentType,\n  selectionSet,\n) {\n  const cached = cachedFieldsAndFragmentNames.get(selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  const nodeAndDefs = Object.create(null);\n  const fragmentNames = Object.create(null);\n\n  _collectFieldsAndFragmentNames(\n    context,\n    parentType,\n    selectionSet,\n    nodeAndDefs,\n    fragmentNames,\n  );\n\n  const result = [nodeAndDefs, Object.keys(fragmentNames)];\n  cachedFieldsAndFragmentNames.set(selectionSet, result);\n  return result;\n} // Given a reference to a fragment, return the represented collection of fields\n// as well as a list of nested fragment names referenced via fragment spreads.\n\nfunction getReferencedFieldsAndFragmentNames(\n  context,\n  cachedFieldsAndFragmentNames,\n  fragment,\n) {\n  // Short-circuit building a type from the node if possible.\n  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);\n  return getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    fragmentType,\n    fragment.selectionSet,\n  );\n}\n\nfunction _collectFieldsAndFragmentNames(\n  context,\n  parentType,\n  selectionSet,\n  nodeAndDefs,\n  fragmentNames,\n) {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case Kind.FIELD: {\n        const fieldName = selection.name.value;\n        let fieldDef;\n\n        if (isObjectType(parentType) || isInterfaceType(parentType)) {\n          fieldDef = parentType.getFields()[fieldName];\n        }\n\n        const responseName = selection.alias\n          ? selection.alias.value\n          : fieldName;\n\n        if (!nodeAndDefs[responseName]) {\n          nodeAndDefs[responseName] = [];\n        }\n\n        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);\n        break;\n      }\n\n      case Kind.FRAGMENT_SPREAD:\n        fragmentNames[selection.name.value] = true;\n        break;\n\n      case Kind.INLINE_FRAGMENT: {\n        const typeCondition = selection.typeCondition;\n        const inlineFragmentType = typeCondition\n          ? typeFromAST(context.getSchema(), typeCondition)\n          : parentType;\n\n        _collectFieldsAndFragmentNames(\n          context,\n          inlineFragmentType,\n          selection.selectionSet,\n          nodeAndDefs,\n          fragmentNames,\n        );\n\n        break;\n      }\n    }\n  }\n} // Given a series of Conflicts which occurred between two sub-fields, generate\n// a single Conflict.\n\nfunction subfieldConflicts(conflicts, responseName, node1, node2) {\n  if (conflicts.length > 0) {\n    return [\n      [responseName, conflicts.map(([reason]) => reason)],\n      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],\n      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()],\n    ];\n  }\n}\n/**\n * A way to keep track of pairs of things when the ordering of the pair does not matter.\n */\n\nclass PairSet {\n  constructor() {\n    this._data = new Map();\n  }\n\n  has(a, b, areMutuallyExclusive) {\n    var _this$_data$get;\n\n    const [key1, key2] = a < b ? [a, b] : [b, a];\n    const result =\n      (_this$_data$get = this._data.get(key1)) === null ||\n      _this$_data$get === void 0\n        ? void 0\n        : _this$_data$get.get(key2);\n\n    if (result === undefined) {\n      return false;\n    } // areMutuallyExclusive being false is a superset of being true, hence if\n    // we want to know if this PairSet \"has\" these two with no exclusivity,\n    // we have to ensure it was added as such.\n\n    return areMutuallyExclusive ? true : areMutuallyExclusive === result;\n  }\n\n  add(a, b, areMutuallyExclusive) {\n    const [key1, key2] = a < b ? [a, b] : [b, a];\n\n    const map = this._data.get(key1);\n\n    if (map === undefined) {\n      this._data.set(key1, new Map([[key2, areMutuallyExclusive]]));\n    } else {\n      map.set(key2, areMutuallyExclusive);\n    }\n  }\n}\n"],"names":["GraphQLError","isObjectType","inspect","getNamedType","Kind","print","sortValueNode","isListType","isNonNullType","isLeafType","typeFromAST","isInterfaceType"],"mappings":"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"}