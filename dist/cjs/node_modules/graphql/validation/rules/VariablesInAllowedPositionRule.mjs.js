'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var inspect = require('../../jsutils/inspect.mjs.js');
var GraphQLError = require('../../error/GraphQLError.mjs.js');
var kinds = require('../../language/kinds.mjs.js');
var definition = require('../../type/definition.mjs.js');
var typeComparators = require('../../utilities/typeComparators.mjs.js');
var typeFromAST = require('../../utilities/typeFromAST.mjs.js');

/**
 * Variables in allowed position
 *
 * Variable usages must be compatible with the arguments they are passed to.
 *
 * See https://spec.graphql.org/draft/#sec-All-Variable-Usages-are-Allowed
 */
function VariablesInAllowedPositionRule(context) {
  let varDefMap = Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        varDefMap = Object.create(null);
      },

      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);

        for (const { node, type, defaultValue } of usages) {
          const varName = node.name.value;
          const varDef = varDefMap[varName];

          if (varDef && type) {
            // A var type is allowed if it is the same or more strict (e.g. is
            // a subtype of) than the expected type. It can be more strict if
            // the variable type is non-null when the expected type is nullable.
            // If both are list types, the variable item type can be more strict
            // than the expected item type (contravariant).
            const schema = context.getSchema();
            const varType = typeFromAST.typeFromAST(schema, varDef.type);

            if (
              varType &&
              !allowedVariableUsage(
                schema,
                varType,
                varDef.defaultValue,
                type,
                defaultValue,
              )
            ) {
              const varTypeStr = inspect.inspect(varType);
              const typeStr = inspect.inspect(type);
              context.reportError(
                new GraphQLError.GraphQLError(
                  `Variable "$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`,
                  {
                    nodes: [varDef, node],
                  },
                ),
              );
            }
          }
        }
      },
    },

    VariableDefinition(node) {
      varDefMap[node.variable.name.value] = node;
    },
  };
}
/**
 * Returns true if the variable is allowed in the location it was found,
 * which includes considering if default values exist for either the variable
 * or the location at which it is located.
 */

function allowedVariableUsage(
  schema,
  varType,
  varDefaultValue,
  locationType,
  locationDefaultValue,
) {
  if (definition.isNonNullType(locationType) && !definition.isNonNullType(varType)) {
    const hasNonNullVariableDefaultValue =
      varDefaultValue != null && varDefaultValue.kind !== kinds.Kind.NULL;
    const hasLocationDefaultValue = locationDefaultValue !== undefined;

    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
      return false;
    }

    const nullableLocationType = locationType.ofType;
    return typeComparators.isTypeSubTypeOf(schema, varType, nullableLocationType);
  }

  return typeComparators.isTypeSubTypeOf(schema, varType, locationType);
}

exports.VariablesInAllowedPositionRule = VariablesInAllowedPositionRule;
//# sourceMappingURL=VariablesInAllowedPositionRule.mjs.js.map
