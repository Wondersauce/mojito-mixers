'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var inspect = require('../../jsutils/inspect.mjs.js');
var GraphQLError = require('../../error/GraphQLError.mjs.js');
var definition = require('../../type/definition.mjs.js');
var typeComparators = require('../../utilities/typeComparators.mjs.js');
var typeFromAST = require('../../utilities/typeFromAST.mjs.js');

/**
 * Possible fragment spread
 *
 * A fragment spread is only valid if the type condition could ever possibly
 * be true: if there is a non-empty intersection of the possible parent types,
 * and possible types which pass the type condition.
 */
function PossibleFragmentSpreadsRule(context) {
  return {
    InlineFragment(node) {
      const fragType = context.getType();
      const parentType = context.getParentType();

      if (
        definition.isCompositeType(fragType) &&
        definition.isCompositeType(parentType) &&
        !typeComparators.doTypesOverlap(context.getSchema(), fragType, parentType)
      ) {
        const parentTypeStr = inspect.inspect(parentType);
        const fragTypeStr = inspect.inspect(fragType);
        context.reportError(
          new GraphQLError.GraphQLError(
            `Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node,
            },
          ),
        );
      }
    },

    FragmentSpread(node) {
      const fragName = node.name.value;
      const fragType = getFragmentType(context, fragName);
      const parentType = context.getParentType();

      if (
        fragType &&
        parentType &&
        !typeComparators.doTypesOverlap(context.getSchema(), fragType, parentType)
      ) {
        const parentTypeStr = inspect.inspect(parentType);
        const fragTypeStr = inspect.inspect(fragType);
        context.reportError(
          new GraphQLError.GraphQLError(
            `Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node,
            },
          ),
        );
      }
    },
  };
}

function getFragmentType(context, name) {
  const frag = context.getFragment(name);

  if (frag) {
    const type = typeFromAST.typeFromAST(context.getSchema(), frag.typeCondition);

    if (definition.isCompositeType(type)) {
      return type;
    }
  }
}

exports.PossibleFragmentSpreadsRule = PossibleFragmentSpreadsRule;
//# sourceMappingURL=PossibleFragmentSpreadsRule.mjs.js.map
